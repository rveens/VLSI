\documentclass[a4paper,twoside,11pt, fleqn]{article}
\usepackage{a4wide,graphicx,fancyhdr,amsmath,amssymb}
\usepackage{listings}
\usepackage{color}
\usepackage{dirtree}

%matlab 
\usepackage[]{mcode}

%----------------------- Macros and Definitions --------------------------

\setlength\headheight{20pt}
\addtolength\topmargin{-10pt}
\addtolength\footskip{20pt}

\newcommand{\N}{\mathbb{N}}
\newcommand{\ch}{\mathcal{CH}}

\newcommand{\solution}[1]{\noindent{\bf Solution to Exercise #1:}}

\fancypagestyle{plain}{%
\fancyhf{}
\fancyhead[LO,RE]{\sffamily\bfseries\large technische universiteit eindhoven}
\fancyhead[RO,LE]{\sffamily\bfseries\large 2IN35 VLSI}
\fancyfoot[LO,RE]{\sffamily\bfseries\large department of mathematics and computer science}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RO,LE]{\sffamily\bfseries\large technische universiteit eindhoven}
\fancyhead[LO,RE]{\sffamily\bfseries\large 2IN35 VLSI}
\fancyfoot[LO,RE]{\sffamily\bfseries\large department of mathematics and computer science}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{0pt}

\def\addsquare#1{\tikz\node[draw]{#1};} 

%-------------------------------- Title ----------------------------------

\title{\vspace{-\baselineskip}\sffamily\bfseries Assignment 4}
\author{
	Rick Veens \qquad Studentno: 0912292\\
	\texttt{r.veens@student.tue.nl}
	\and
	Barry de Bruin \qquad Studentno: 0919605\\
	\texttt{e.d.bruin@student.tue.nl}
	\and
	\texttt{Group 7}
}

\date{\today}

\setlength\parindent{0pt}

%--------------------------------- Text ----------------------------------

\begin{document}
\maketitle
\newpage

\tableofcontents

\newpage

\section{Exercise 1}
\section{Exercise 2}
If we take for example L = 5 and M = 4, we get the following graph, while following the direct equation, we get for different y(n):

\begin{align}
y[n] &= \sum_{j=0}^3 h[j\cdot L + n\cdot M \textbf{ mod } L]\cdot x[n\cdot M \textbf{ div } L - j]\\
&= \sum_{j=0}^3 h[j\cdot 5 + n\cdot 4 \textbf{ mod } 5]\cdot x[n\cdot 4 \textbf{ div } 5 - j]
\end{align}


for n = 0 we get for j = 0 to 3:
\begin{align}
y[0] &= h[0\cdot 5 + 0\cdot 4 \textbf{ mod } 5]\cdot x[0\cdot 4 \textbf{ div } 5 - 0]\\ 
&= h[0]\cdot x[0] \\
y[0] &= h[1\cdot 5 + 0\cdot 4 \textbf{ mod } 5]\cdot x[0\cdot 4 \textbf{ div } 5 - 1] \\
&= h[5]\cdot x[-1] \\
y[0] &= h[2\cdot 5 + 0\cdot 4 \textbf{ mod } 5]\cdot x[0\cdot 4 \textbf{ div } 5 - 2] \\
&= h[10]\cdot x[-2] \\
y[0] &= h[3\cdot 5 + 0\cdot 4 \textbf{ mod } 5]\cdot x[0\cdot 4 \textbf{ div } 5 - 3] \\
&= h[15]\cdot x[-3] \\
\end{align}

for n = 1 we get for j = 0 to 3:
\begin{align}
y[1] &= h[0\cdot 5 + 1\cdot 4 \textbf{ mod } 5]\cdot x[1\cdot 4 \textbf{ div } 5 - 0]]\\ 
&= h[4]\cdot x[0] \\
y[1] &= h[1\cdot 5 + 1\cdot 4 \textbf{ mod } 5]\cdot x[1\cdot 4 \textbf{ div } 5 - 1]] \\
&= h[9]\cdot x[-1] \\
y[1] &= h[2\cdot 5 + 1\cdot 4 \textbf{ mod } 5]\cdot x[1\cdot 4 \textbf{ div } 5 - 2]] \\
&= h[14]\cdot x[-2] \\
y[1] &= h[3\cdot 5 + 1\cdot 4 \textbf{ mod } 5]\cdot x[1\cdot 4 \textbf{ div } 5 - 3]] \\
&= h[19]\cdot x[-3] \\
\end{align}

for n = 2 we get for j = 0 to 3:
\begin{align}
y[1] &= h[0\cdot 5 + 2\cdot 4 \textbf{ mod } 5]\cdot x[2\cdot 4 \textbf{ div } 5 - 0]]\\ 
&= h[3]\cdot x[1] \\
y[1] &= h[1\cdot 5 + 2\cdot 4 \textbf{ mod } 5]\cdot x[2\cdot 4 \textbf{ div } 5 - 1]] \\
&= h[8]\cdot x[0] \\
y[1] &= h[2\cdot 5 + 2\cdot 4 \textbf{ mod } 5]\cdot x[2\cdot 4 \textbf{ div } 5 - 2]] \\
&= h[13]\cdot x[-1] \\
y[1] &= h[3\cdot 5 + 2\cdot 4 \textbf{ mod } 5]\cdot x[2\cdot 4 \textbf{ div } 5 - 3]] \\
&= h[18]\cdot x[-2] \\
\end{align}

for n = 3 we get for j = 0 to 3:
\begin{align}
y[1] &= h[0\cdot 5 + 3\cdot 4 \textbf{ mod } 5]\cdot x[3\cdot 4 \textbf{ div } 5 - 0]]\\ 
&= h[2]\cdot x[2] \\
y[1] &= h[1\cdot 5 + 3\cdot 4 \textbf{ mod } 5]\cdot x[3\cdot 4 \textbf{ div } 5 - 1]] \\
&= h[7]\cdot x[1] \\
y[1] &= h[2\cdot 5 + 3\cdot 4 \textbf{ mod } 5]\cdot x[3\cdot 4 \textbf{ div } 5 - 2]] \\
&= h[12]\cdot x[0] \\
y[1] &= h[3\cdot 5 + 3\cdot 4 \textbf{ mod } 5]\cdot x[3\cdot 4 \textbf{ div } 5 - 3]] \\
&= h[17]\cdot x[-1] \\
\end{align}

for n = 4 we get for j = 0 to 3:
\begin{align}
y[1] &= h[0\cdot 5 + 4\cdot 4 \textbf{ mod } 5]\cdot x[4\cdot 4 \textbf{ div } 5 - 0]]\\ 
&= h[1]\cdot x[3] \\
y[1] &= h[1\cdot 5 + 4\cdot 4 \textbf{ mod } 5]\cdot x[4\cdot 4 \textbf{ div } 5 - 1]] \\
&= h[6]\cdot x[2] \\
y[1] &= h[2\cdot 5 + 4\cdot 4 \textbf{ mod } 5]\cdot x[4\cdot 4 \textbf{ div } 5 - 2]] \\
&= h[11]\cdot x[1] \\
y[1] &= h[3\cdot 5 + 4\cdot 4 \textbf{ mod } 5]\cdot x[4\cdot 4 \textbf{ div } 5 - 3]] \\
&= h[16]\cdot x[0] \\
\end{align}

Now it starts repeating:\\

for n = 5 we get for j = 0 to 3:
\begin{align}
y[1] &= h[0\cdot 5 + 5\cdot 4 \textbf{ mod } 5]\cdot x[5\cdot 4 \textbf{ div } 5 - 0]]\\ 
&= h[0]\cdot x[0] \\
y[1] &= h[1\cdot 5 + 5\cdot 4 \textbf{ mod } 5]\cdot x[5\cdot 4 \textbf{ div } 5 - 1]] \\
&= h[5]\cdot x[-1] \\
y[1] &= h[2\cdot 5 + 5\cdot 4 \textbf{ mod } 5]\cdot x[5\cdot 4 \textbf{ div } 5 - 2]] \\
&= h[10]\cdot x[-2] \\
y[1] &= h[3\cdot 5 + 5\cdot 4 \textbf{ mod } 5]\cdot x[5\cdot 4 \textbf{ div } 5 - 3]] \\
&= h[15]\cdot x[-3] \\
\end{align}


\newpage
\section{Exercise 3}
We have the following 4 designs: 

\subsection{Direct equation solution}
This solution uses the direct equation and has two different implementations: The direct method that has a single direct equation stage, and the composite implementation that uses two stages.

\smallskip
\textbf{Direct method}\\
This implementation uses $4\cdot L$ coefficients and needs only 4 multiplications/additions. All inner factors can be pre-computed.
\smallskip
The highest sample rate inside the system (system frequency) will be input or output sample frequency, depending on the L and M constants. Therefore: $F_{system} = max(Fs_{in}, Fs_{out})$.
 
\smallskip 
\textbf{Composite method}\\
Uses $4\cdot (L_{sub1} + L_{sub2})$ coefficients, while $L = L_{sub1} \cdot L_{sub2}$. Therefore we need less coefficients compared to the direct method. Since every sample still needs 4 multiplications/additions, we actually need 8 multiplication/additions for this implementation.

\smallskip
If we compose a resampler of two of those systems, the highest system frequency will be input frequency of the first system, the output of the first system (input of second system), or the output of the second system.

\subsection{Naive solution}
Uses the complete part of an upscaler, low-pass filter and downscaler. Again we have two variants:

\smallskip
\textbf{Direct scalers}\\
Since the filter in this implementation is just a low-pass FIR filter, we need one multiplication/addition step for every coefficient. This is not very efficient because L-1 out of L samples are zero and will therefore not influence the output signal. Because $4\cdot L$ coefficients are needed to filter out the high-frequency noise, we need the same amount of multiplication/additions for one output sample.

\smallskip
The maximum system frequency will be $F_{system} = F_s\cdot L$ Hz, which is the sampling frequency of the low-pass filter. This is also shown in figure xx below:
\begin{figure}[h]
	\includegraphics[scale = 1]{Images/3_0}
    \caption{Naive solution with single set of stages}
\end{figure}

\newpage
\textbf{Composite scalers } \\
Now we actually have two stages and therefore we need to apply the FIR filter in both stages. This will actually cost us $4\cdot (L_1 + L_2)$ multiplication/addition steps, where still L-1 out of L samples are zero.

\smallskip
The maximum system frequency will be $F_{system} = max(F_s\cdot L_1, F_s\cdot \frac{L_1\cdot L_2}{M_1})$, since one of the two stages can have the highest frequency, depending on the L and M parameters.
\begin{figure}[h]
	\includegraphics[scale = 1]{Images/3_1}
    \caption{Naive solution with double set of stages}
\end{figure}

\subsection{Conclusion}
The best solution may depend on your needs. If your L is really large, we may consider using a composite solution to exchange coefficient memory for additional arithmetic steps. The naive method does make a lot of useless computations, while the direct equation method has almost no computations with a zero factor.\\


\newpage
\section{Implementation}
Since input frequency is only 44khz, and output frequency only 48khz, we can just implement this by using a single DSP unit.\\

I generate the coefficients using matlab. They are in the coef.bin file, and already multiplied by $2^{16}$ and rounded.\\

If the lanczos2 function gives a close to one output, the quantized value will be close to the maximum that a 16-bit value can hold. Therefore 16-bit is not enough to store the summation and multiplication of multiple of such values.\\

\subsection{Requirements}
\begin{enumerate}
	\item The output sample rate must be $\frac{48000}{44100}$ times the input sample rate.
	\item The output represents a resampled version of the input.
	\item The design must support an input sample rate of at least 44.1kHz.
	\item The design must be able to run at a clock frequency of at least 100Mhz.
	\item The design may produce start-up noise.
	\item The top-level Verilog module must be called filter.
\end{enumerate}


\subsubsection{Analysis of requirements}

\newpage
\subsection{System architecture}
The resampler is based on the direct equation solution. It uses a state machine that works almost identical as the standard state machine provided in lab 2 and 3. \\

To calculate one output, we need 4 samples. To store the samples we have introduced a FIFO buffer. We calculate one output during 4 iterations.  Every iteration one tap is calculated. If we do not have to re-use the sample for next out, the samples will be shifted by one during the calculation, but only if the shift enable is '1'.\\

The resampler also uses 2 lookup tables:
\begin{enumerate}
\item \textbf{coefficients index LUT}: This table stores which coefficient we should use for the calculation of the current output.
\item \textbf{sample shift LUT}: This table stores a '1' or a '0'. If the current output index points to a '0', the data FIFO will not be shifted, since next output will also use the same samples. If it points to a '1', the data FIFO  will be shifted, because next output needs a new sample.
\end{enumerate}

\begin{figure}[h]
	\includegraphics[scale = 1]{Images/4_blockdiagram}
    \caption{Block diagram of resampler from direct equation}
\end{figure}


\newpage
\subsection{Design choices}
The resampler is based on the direct equation solution, and uses a single scaler. This is done because the naive solution needs a high internal sample frequency (that scales  with the upsample rate), and it does a lot of unnecessary multiplications by zero. It is probably possible to implemented a composite direct equation solution which shares resources (DSP units) and also uses less registers, but this will introduce additional complexity which we avoided.\\

The resampler uses a state machine that works almost identical as the standard state machine provided in lab 2 and 3. The reason why we have rewritten this state machine is that it was hard to see what was actually going on because a lot of states have almost the same requirements. Furthermore, the execution order of all states is mostly the same. Therefore, a state machine did make sense. This also allowed for easier pipelining (just split one state in two).\\

The coefficients are loaded in a Block RAM, and a LUT is connected to it. This LUT defines which coefficients should be used during the calculation of the current output. Another LUT is initialized to tell the system if it should re-use the current data.\\

The sum register stores the temporary results during the calculation of an output. It uses 25 bits, which are truncated to the 16 MSB when the output is ready. 
\textbf{NEED MORE ELABORATION, CANT FULLY REASON ON THIS}.



\subsection{Functional correctness}

\subsection{Resource usage}

\subsection{System throughput and latency}

\subsection{Simulation results}

\newpage
\section{Appendix A: Matlab coefficients script}
\begin{lstlisting}
% Put this in a file named coef_generate_matlab.m, 
% then call it while you are in the file directory


function [y] = coef_generate_matlab(L)
        % make sure that coefficients sum to 1
        y = coef_gen(L);
        y = coef_gen(L)/sum(y);

        % quantize and round to nearest integer
        y = round(y*(2^16)); 
             
        % convert to signed int filter coeff
        y = int16(y);
        y = hex(fi(y, 1, 16, 0)); %1 stands for signed, 16 bit out
        y= y(~isspace(y)); % remove spaces
        dlmwrite('coef.txt',y,''); %create file, with no delimiter ''      
end

function [y] = coef_gen(L)
    % generate 4*L coefficients and start at 0 instead of 1 *stupid matlab*
    for n = 1:4*L
            y(n) = lanczos2(((n-1)/L) -2);
    end
end

function y = lanczos2(t)
    if(t <= -2 || t >= 2)
        y = 0;
    else
        y = sinc(t).*sinc(t/2);
    end
end

%%
\end{lstlisting}

\newpage
\section{Appendix B: Verilog Code}

\end{document}
